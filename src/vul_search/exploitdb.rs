use serde::Deserialize;

use crate::{error::*, service_analyse::ServiceVuln};
pub struct ExploitDBSearch {
    shell_cmd: String,
}

#[derive(Deserialize)]
struct ExploitDBExploit {
    #[serde(rename = "Title")]
    title: String,
    #[serde(rename = "EDB-ID")]
    id: String,
}

#[derive(Deserialize)]
struct ExploitDBSearchResult {
    #[serde(rename = "RESULTS_EXPLOIT")]
    results: Vec<ExploitDBExploit>,
}

impl ExploitDBSearch {
    pub fn new(cmd: String) -> Self {
        Self {
            shell_cmd: cmd
        }
    }

    pub async fn search(&self, name: &str, version: &str) -> Result<Vec<ServiceVuln>, SimpleError> {
        let mut cmd = tokio::process::Command::new("bash");

        cmd.arg(&self.shell_cmd)
            .arg("-j")
            .arg("--id")
            .arg(name);

        if version != "" {
            cmd.arg(version);
        }
        let output = cmd.output().await?;

        if !output.status.success() {
            Err("Failed to get output")?
        }

        let result = serde_json::from_slice::<ExploitDBSearchResult>(&output.stdout[..])?;
        
        Ok(result.results.into_iter().map(|exploit| ServiceVuln {
            id: format!("EDB-{}", exploit.id),
            title: exploit.title,
            url: format!("https://www.exploit-db.com/exploits/{}", exploit.id)
        }).collect())
    }
}
