use mongodb::{Database, bson::{self, doc}, options::UpdateOptions};
use redis::{pipe};
use serde::Deserialize;

use crate::{error::*, vul_search::{ServiceVulns, VulnInfo, HIT_RATE_STATS}};
pub struct ExploitDBSearch {
    shell_cmd: String,
    db: Database,
    redis: redis::aio::Connection,
}

#[derive(Deserialize)]
struct ExploitDBExploit {
    #[serde(rename = "Title")]
    title: String,
    #[serde(rename = "EDB-ID")]
    id: String,
}

#[derive(Deserialize)]
struct ExploitDBSearchResult {
    #[serde(rename = "RESULTS_EXPLOIT")]
    results: Vec<ExploitDBExploit>,
}

const COLLECTION: &str = "vulns";
const KEY_EDB: &str = "vulns:exploit-db";
macro_rules! redis_key {
    ($service: expr, $version: expr) => {
        match $version {
            "" => format!("{}:{}:unknown", KEY_EDB, $service),
            _ => format!("{}:{}:{}", KEY_EDB, $service, $version),
        }
    };
}

impl ExploitDBSearch {
    pub async fn new(cmd: String, db: Database, redis: redis::Client) -> Result<Self, SimpleError> {
        Ok(Self {
            shell_cmd: cmd,
            redis: redis.get_async_connection().await?,
            db,
        })
    }

    pub async fn search(&mut self, name: &str, version: &str) -> Result<Vec<String>, SimpleError> {
        match self.search_cache(name, version).await {
            Ok(vulns) => Ok(vulns),
            _ => self.search_edb(name, version).await
        }
    }

    async fn search_cache(&mut self, service: &str, version: &str) -> Result<Vec<String>, SimpleError> {
        let key = redis_key!(service, version);
        let result: (bool, Vec<String>) = pipe()
            .exists(&key)
            .lrange(&key, 0, -1)
            .query_async(&mut self.redis).await?;

        let mut guard = HIT_RATE_STATS.lock().await;
        guard.access_count += 1;
        match result {
            (false, _) => Err("Notfound")?,
            (true, vulns) if vulns[0] != "" => {
                guard.hit_count += 1;
                // log::info!("Searched {}:{} from cache", service, version);
                Ok(vulns)
            },
            (true, mut vulns) => {
                guard.hit_count += 1;
                // log::info!("Searched {}:{} from cache but empty", service, version);
                vulns.clear();
                Ok(vulns)
            }
        }
    }

    async fn search_edb(&mut self, service: &str, version: &str) -> Result<Vec<String>, SimpleError> {
        let mut cmd = tokio::process::Command::new("bash");

        cmd.arg(&self.shell_cmd)
            .arg("-j")
            .arg("--id")
            .arg(service);

        if version != "" {
            cmd.arg(version);
        }
        let output = cmd.output().await?;

        if !output.status.success() {
            Err("Failed to get output")?
        }

        let result = serde_json::from_slice::<ExploitDBSearchResult>(&output.stdout[..]).map_err(|err| {
            log::warn!("{:?}", std::str::from_utf8(&output.stdout[..]));
            err
        })?;
        
        let vulns: Vec<VulnInfo> =  result.results.into_iter().map(|exploit| VulnInfo {
            id: format!("EDB-{}", exploit.id),
            title: exploit.title,
            url: format!("https://www.exploit-db.com/exploits/{}", exploit.id)
        }).collect();

        let collection = self.db.collection::<ServiceVulns>(COLLECTION);

        let mut opts = UpdateOptions::default();
        opts.upsert = Some(true);
        for vuln in &vulns {
            let query = doc! {
                "id": &vuln.id,
            };
            let update = doc! {
                "$set": bson::to_bson(vuln)?
            };
            collection.update_one(query, update, opts.clone()).await?;
        }
        

        let vulns: Vec<String> = vulns.into_iter()
            .map(|vuln|vuln.id).collect();
        
        if vulns.len() <= 0 {
            pipe()
                .del(redis_key!(service, version)).ignore()
                .lpush(redis_key!(service, version), "").ignore()
                .expire(redis_key!(service, version), 86400).ignore()
                .query_async(&mut self.redis).await?;
        } else {
            pipe()
                .del(redis_key!(service, version)).ignore()
                .lpush(redis_key!(service, version), vulns.clone()).ignore()
                .expire(redis_key!(service, version), 86400).ignore()
                .query_async(&mut self.redis).await?;
        }

        log::info!("Searched {}:{} from exploit-db-search", service, version);

        Ok(vulns)
    }
}
